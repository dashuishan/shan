import cv2 as cv
import sys
if __name__=='__main__':
    #读取图形并判断是否成功
    img=cv.imread('./images/flower.jpg')
    if img is None:
        print('Failed to read flower.jpg.')
    else:
        print('图像的形状：{}\n元素数据类型:{}\n图像通道数:{}\n像素总数:{}'.format(img.shape,img.dtype,img.ndim,img.size))

Process finished with exit code 0
    #图像的形状：(442, 442, 3)
    #元素数据类型:uint8
    #图像通道数:3
    #像素总数:586092
    ##foamat函数的用法括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换
    #print("我叫{},今年{}!".format("张三", 22))
    #我叫张三, 今年22!
    ################################################################################################
    import cv2 as cv
import numpy as np
import datetime
import sys


if __name__ == '__main__':
    # 创建ndarray对象
    # 使用np.array()创建一个5*5，数据类型为float32的对象
    a = np.array([[1, 2, 3, 4, 5],
                  [6, 7, 8, 9, 10],
                  [11, 12, 13, 14, 15],
                  [16, 17, 18, 19, 20],
                  [21, 22, 23, 24, 25]], dtype='float32')
    # 使用np.ones()创建一个5*5，数据类型为uint8的全1对象
    b = np.ones((5, 5), dtype='uint8')
    # 使用np.zeros()创建一个5*5，数据类型为float32的全0对象
    c = np.zeros((5, 5), dtype='float32')
    print('创建对象（np.array）：\n{}'.format(a))
    print('创建对象（np.ones）：\n{}'.format(b))
    print('创建对象（np.zeros）：\n{}'.format(c))

    # ndarray对象切片和索引
    image = cv.imread('./images/flower.jpg')
    # 判断图片是否读取成功
    if image is None:
        print('Failed to read flower.jpg.')
        sys.exit()
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    #cvtColor()函数是OpenCV里的颜色空间转换函数，可以实现RGB颜色向HSV、HSI等颜色空间的转换，也可以转换为灰度图像。
    # 读取图像位于（45,45）位置的像素点
    print('位于（45,45）位置的像素点为：{}'.format(gray[45, 45]))
    # 裁剪部分图像（灰度图像和RGB图像）
    res_gray = gray[40:280, 60:340]
    res_color1 = image[40:280, 60:340, :]
    res_color2 = image[100:220, 80:220, :]
    # 通道分离
    b = image[:, :, 0]
    g = image[:, :, 1]
    r = image[:, :, 2]
    # 展示裁剪和分离通道结果
    cv.imshow('Result crop gray', res_gray)
    cv.imshow('Result crop color1', res_color1)
    cv.imshow('Result crop color2', res_color2)
    cv.imshow('Result split b', b)
    cv.imshow('Result split g', g)
    cv.imshow('Result split r', r)

    # 生成随机数
    # 生成一个5*5，取值范围在0-100的数组
    values1 = np.random.randint(0, 100, (5, 5), dtype='uint8')
    # 生成一个2*3，元素服从平均值为0、标准差为1正态分布的数组，np.random.randn()是以0为均值、以1为标准差的正态分布，记为N（0，1）。
    values2 = np.random.randn(2, 3)
    print('生成随机数（np.random.randint）：\n{}'.format(values1))
    print('生成随机数（np.random.randn）：\n{}'.format(values2))

    cv.waitKey(0)
    cv.destroyAllWindows()
#. waitKey()–是在一个给定的时间内(单位ms)等待用户按键触发; 如果用户没有按下键,则继续等待 (循环)。常见 : 设置 waitKey(0) , 则表示程序会无限制的等待用户的按键事件，按任意键继续
####################################################################################################################################################
import cv2 as cv
import numpy as np
import datetime
import sys
if __name__ == '__main__':
    image = cv.imread('./images/flower.jpg')
    # 判断图片是否读取成功
    if image is None:
        print('Failed to read flower.jpg.')
        exit()

    # 对比通道的分离
    # 使用opencv中的cv.split()函数
    begin1 = datetime.datetime.now()
    for i in range(100000):
        b1, g1, r1 = cv.split(image)
    end1 = datetime.datetime.now()
    print('通道分离(opencv)：{}s'.format((end1 - begin1).total_seconds()))
    # 使用numpy中的切片和索引
    begin2 = datetime.datetime.now()
    for i in range(100000):
        b2 = image[:, :, 0]
        g2 = image[:, :, 1]
        r2 = image[:, :, 2]
    end2 = datetime.datetime.now()
    print('通道分离(numpy)：{}s'.format((end2 - begin2).total_seconds()))

    # 对比BGR图像转为RGB图像
    # 使用opencv中cv.cvtColor()函数
    begin3 = datetime.datetime.now()
    for i in range(100000):
        image_rgb = cv.cvtColor(image, cv.COLOR_BGR2RGB)
    end3 = datetime.datetime.now()
    print('BGR转RGB(opencv)：{}s'.format((end3 - begin3).total_seconds()))
    # 使用numpy中的切片和索引
    begin4 = datetime.datetime.now()
    for i in range(100000):
        image_rgb = image[:, :, ::-1]
        #img[:,:,::-1]也就是我们任意不改变width维的方式，也不改变height维的方式，仅仅改变channel维的方式，并且是倒序排列，原本的bgr排列方式经过倒序就变成了rgb的通道排列方式。
        #img = img[:, :, ::-1].transpose(2, 0, 1)，transpose输入顺序NxCxHxW,我们将图片从HxWxC改为CxHxW的形式。
        #img[::-1, :, :]其实是对图片进行上下翻转， img[:,::-1,:]是对图像进行左右翻转
    end4 = datetime.datetime.now()
    print('BGR转RGB(numpy)：{}s'.format((end4 - begin4).total_seconds()))
#首先需要明白一点，我们通过cv2读图片时，数据读取的通道顺序是bgr，并且是height， width， channel的排列方式。
运行后结果为：
通道分离(opencv)：8.014632s
通道分离(numpy)：0.042004s
BGR转RGB(opencv)：2.087166s
BGR转RGB(numpy)：0.020182s
# 在python中经常会用到计算两个时间差，两个日期类型进行相减可以获取到时间差。经常会使用seconds来获取，其实seconds获取的是仅仅是时间差的秒数，忽略微秒数，忽略天数。
# total_seconds()是获取两个时间之间的总差
# t1 = datetime.datetime.strptime("2017-9-06 10:30:00", "%Y-%m-%d %H:%M:%S")
# t2 = datetime.datetime.strptime("2017-9-08 12:30:00", "%Y-%m-%d %H:%M:%S")
# interval_time = (t2 - t1).seconds  # 输入的结果：7200
# total_interval_time = (t2 - t1).total_seconds() # 输出结果是: 180000.0
# print interval_time
# print total_interval_time
######################################################这里使用numpy和opecv两种方法去对比，对图片进行处理的效率问题。
import cv2 as cv
if __name__ == '__main__':
    video = cv.VideoCapture('./videos/road.mp4')
    # 判断是否成功创建视频流
    while video.isOpened():
        ret, frame = video.read()#ret变量表示是否成功从vidio中读出图像，读出则为true，没读出为false。也用来判断是否视频是否到了末尾。
        if ret is True:
            cv.imshow('Video', frame)
            # 设置视频播放速度
            # 读者可以尝试将该值做更改，并观看视频播放速度的变化
            cv.waitKey(int(1000 / video.get(cv.CAP_PROP_FPS)))
            #，当imshow之后不跟waitkey时，相当于没有给imshow提供时间展示图像，所以只有一个空窗口一闪而过。添加了waitkey后，哪怕仅仅是cv2.waitkey(1),我们也能截取到一帧的图像。所以cv2.imshow后边是必须要跟cv2.waitkey的。
            #imshow（）后面必接cv.waitkey()，以显示图像。必须必须接！！This function is the only method in HighGUI that can fetch and handle events,so it needs to be
            # 按下q退出
            if cv.waitKey(1) & 0xFF == ord('q'):
            #0xFF是一个十六进制数，转换为二进制是11111111。waitKey返回值的范围为（0-255），刚好也是8个二进制位。那么我们将 cv2.waitKey(1) & 0xFF计算一下（不知怎么计算的可以百度位与运算）发现结果仍然是waitKey的返回值，那为何要多次一举呢？直接 cv2.waitKey(1) == ord('q')不就好了吗。
            #实际上在linux上使用waitkey有时会出现waitkey返回值超过了（0-255）的范围的现象。通过cv2.waitKey(1) & 0xFF运算，当waitkey返回值正常时 cv2.waitKey(1) = cv2.waitKey(1000) & 0xFF,当返回值不正常时，cv2.waitKey(1000) & 0xFF的范围仍不超过（0-255），就避免了一些奇奇怪怪的BUG。
            #ord('q')的意思是返回q的ascii码，
                break
        else:
            break
    # 输出相关信息
    print('视频中图像的宽度为：{}'.format(video.get(cv.CAP_PROP_FRAME_WIDTH)))
    print('视频中图像的高度为：{}'.format(video.get(cv.CAP_PROP_FRAME_HEIGHT)))
    print('视频帧率为：{}'.format(video.get(cv.CAP_PROP_FPS)))
    print('视频总帧数为：{}'.format(video.get(cv.CAP_PROP_FRAME_COUNT)))
    #cv.VideoCapture提供了get(propID)函数来获取视频属性，如视频的像素大小、帧数和帧率。
    # 释放并关闭窗口
    video.release()
    cv.destroyAllWindows()
    ########################################################################################读取视频的方法。
