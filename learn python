#这里讲的是and or是怎么用的。
如果a, b是逻辑变量， 则两类的用法基本一致

In[103]:(3>0) | (3<1)
Out[103]: True
In[104]:(3>0) and (3<1)# 注意这里是有（）的
Out[104]: False
In[105]:(3>0) or (3<1)
Out[105]: True
In[106]:(3>0) & (3<1)
Out[106]: False
————————————————
如果a，b是数值变量， 则&， |表示位运算， and，or则依据是否非0来决定输出，
&， |怎么用：
# 1&2，2在二进制里面是10,1在二进制中是01，那么01与运算10得到是0 
1 & 2         # 输出为 0， 
1 | 2         # 输出为3

#自写程序 shan
age=30
if age<2:
    print("he is infant")
elif (age>2) & (age<13):
    print("he is a child")
elif (age>13) & (age<20):
    print("he is a kid")
elif (age>20) & (age<65):
    print("he is a man")
elif age>65:
    print("he is old man")
 
 #在Python中：False、0、''、[]、{}、()都视为假，因此可以直接进行逻辑运算。此方法效率最高，但可读性较差，无法准确预知原先的数据类型具体是什么，只是非常模糊地知道可能是False、0、''、[]、{}、()这6种类型中的一种。
 usernames = []
if usernames:
    for username in usernames:
        if username=='admin':
            print("hello admin ,i love you")
        else:
            print(f"hello ,{username},you are not welcome xiaolaji")
else:
    print("你是个空的，")

#这个案例教你怎么去掉大小写识别。
# current_users = ['eric', 'willie', 'admin', 'erin', 'Ever']
# new_users = ['sarah', 'Willie', 'PHIL', 'ever', 'Iona']
# current_users_lower=
# for new_user in new_users:
#     if new_user.lower()in current_users.lower():#这样书写是错误的，原因是current_users是个列表，不能直接调用lower()方法。
#         print("有重名，清更换")
#     else:
#         print("谢谢，注册成功")
current_users = ['eric', 'willie', 'admin', 'erin', 'Ever']
new_users = ['sarah', 'Willie', 'PHIL', 'ever', 'Iona']

current_users_lower=[current_user.lower() for current_user in current_users]
for new_user in new_users:
    if new_user.lower() in current_users_lower:
        print("有重名，清更换")
    else:
        print("谢谢，注册成功")
#注意这里使用了列表的生成的方法，###################################
python3的列表生成式主要有3种：
for循环+if ------- [i for i in xxx if x xxx]
for循环+if else --------- [i if exp1 else exp2 for i in xxx]
多层for循环 ----------- [for i in xxx for j in xxx]
# 列表生成式1  for循环+if
# [i for i in xxx if x xxx]
# 此处的if语句主要起判断的作用,if在后
a = [i for i in [1,2,3,4] if i > 2]
print(a)
result [3,4]
# 列表生成式2   for循环+if else
# [i if exp1 else exp2 for i in xxx]
# 此处的if else语句主要起赋值的作用,if---else----在前
a = [i if i>2 else 0 for i in [1,2,3,4,5]]
print(a)
result [0,0,3,4,5]
# 列表生成式3  多层for循环
# [for i in xxx for j in xxx]
a = [i+j for i in 'abc' for j in 'mnp']
print(a)
result ['am','an','ap','bm','bn','bp','cm','cn','cp']
########################################################
for i in range(1,10):
    if i==1:
        print("1st")
    elif i==2:
        print("2nd")
    elif i==3:
        print("3rd")
    else:
        print(f"{i}th")
    ##########################################################
    
    person={'first_name':'jiang','last_name':'shan','age':28,'city':'yichun'}
print(person['first_name'])
print(person['last_name'])
print(person['age'])
print(person['city'])
###################################################################
favirite_number={
    'andy':1,
    'shan':2,
    'xing':3,
    'fang':4,
    'huang':5
}
print(f"andy has the favirite number is {favirite_number['andy']}")
###########################################################################
glossary = {
 'string': 'A series of characters.',
 'comment': 'A note in a program that the Python interpreter ignores.',
 'list': 'A collection of items in a particular order.',
 'loop': 'Work through a collection of items, one at a time.',
 'dictionary': "A collection of key-value pairs.",
 }
for keyword in glossary:

    word=keyword
    print(f"{word.title()} means {glossary[word]}, thank you")#我在想字典中怎么写循环呢？我尝试下，结果成功了。
      #######################################################################################
    glossary = {
 'string': 'A series of characters.',
 'comment': 'A note in a program that the Python interpreter ignores.',
 'list': 'A collection of items in a particular order.',
 'loop': 'Work through a collection of items, one at a time.',
 'dictionary': "A collection of key-value pairs.",
 'key': 'The first item in a key-value pair in a dictionary.',
 'value': 'An item associated with a key in a dictionary.',
 'conditional test': 'A comparison between two values.',
 'float': 'A numerical value with a decimal component.',
 'boolean expression': 'An expression that evaluates to True or False.',
 }
for key,means in glossary.items():##这里终于学会了字典的循环调用了，好开心。item（）是个宝，家家离不了。
    print(f"\n{key}:{means}")
##################################################################################################20230527
    rivers = {
 'nile': 'egypt',
 'mississippi': 'united states',
 'fraser': 'canada',
'kuskokwim': 'alaska',
 'yangtze': 'china',
 }
for river,country in rivers.items():
    print(f"-the {river.title()}  run though the {country} ")
    print(f"-{river.title()}")
    print(f"-{country.title()}")
  ######################################################################################################
favorite_languages = {
 'jen': 'python',
 'sarah': 'c',
 'edward': 'ruby',
 'phil': 'python',
 }
for name,language in favorite_languages.items():
    print(f"{name.title()}  favorite language is {language.title()} ")
coders = ['phil', 'josh', 'david', 'becca', 'sarah', 'matt', 'danielle']
for code in coders:
    if code in favorite_languages.keys():#注意这里的keys()，指的是字典里面的KEY值。
        print(f"{code},thank you")
    else:
        print(f"{code},麻烦填写，谢谢！")
        ####################################################################################################
        people=[]
person1 = {
 'first_name': 'eric',
 'last_name': 'matthes',
 'age': 43,
 'city': 'sitka',
 }
people.append(person1)
person2 = {
 'first_name': 'jiang',
 'last_name': 'shan',
 'age': 23,
 'city': 'yichun',
 }
people.append(person2)
person3 = {
 'first_name': 'bing',
 'last_name': 'gan',
 'age': 13,
 'city': 'binzhou',
 }
people.append(person3)
for person in people:
    print(f"{person['first_name']}{person['last_name']} age is {person['age']} and live in {person['city']}")
###############################################################################看这里字典是怎么合成列表的，列表是输出每个内容的。
pets=[]
pet = {
 'animal type': 'python',
 'name': 'john',
 'owner': 'guido',
 'weight': 43,
 'eats': 'bugs',
}
pets.append(pet)
pet = {
 'animal type': 'chicken',
 'name': 'clarence',
 'owner': 'tiffany',
 'weight': 2,
 'eats': 'seeds',
}
pets.append(pet)
pet = {
 'animal type': 'dog',
 'name': 'peso',
 'owner': 'eric',
 'weight': 37,
 'eats': 'shoes',
}
pets.append(pet)
for pet in pets:
    print(f"let us know about {pet['name']}")
    for key,information in pet.items():
        print(f"{key}:{information}")
        ###############################################################
favorite_places = {
 'eric': ['bear mountain', 'death valley', 'tierra del fuego'],
 'erin': ['hawaii', 'iceland'],
 'willie': ['mt. verstovia', 'the playground', 'new hampshire']
 }
for name,favorite_place in favorite_places.items():#我在想是不是只有字典的键值是一个的时候，才会使用这个item（）呢？
    print(f"{name.title()} favorite places is :")
    for place in favorite_place:
        print(f"- {place.title()}.")##这个案例是字典中 一个key对应 多个数值的问题，这些数值是用列表的形式表现出来的。
     ##################################################################
cities = {
 'santiago': {
 'country': 'chile',
 'population': 6_310_000,
 'nearby mountains': 'andes',
 },
 'talkeetna': {
 'country': 'united states',
 'population': 876,
 'nearby mountains': 'alaska range',
 },
 'kathmandu': {
 'country': 'nepal',
 'population': 975_453,
 'nearby mountains': 'himilaya',
 }
 }
for city,informations in cities.items():
    print(f" the city {city.title() :}")
    for key,information in informations.items():
        print(f"{key}：{information}")
###############################################################这里是字典中嵌套字典的方式，我也使用了，两个for 循环的方式，跟答案使用字典的key[]方法有所不同
message = input("Tell me something, and I will repeat it back to you: ")
print(message.title())
##############################################################################
party_size=input("how many peopel are in your dinner party tonight?")
party_size=int(party_size)

if party_size>8:
    print("没有空位")
else:
    print("有空位，请进来。")
#######################################################################
num=input("Give me a number,please:")
num=int(num)

if num%10==0:#%表示取模运算符。
    print(f"{num}是10的倍数")
else:
    print(f"{num}不是10的倍数")
####################################################################
prompt="\n what topping would you like on your pizza?,enter 'quit' when you are finished."
#prompt+="\n enter 'quit' when you are finished."

while True:
    topping=input(prompt)
    if topping!='quit':
        print(f"we will add {topping} in your pizza")
    else:
        break#这个是初入门while break的用法，用来中止这段话使用。
     ########################################################################
     prompt=input("how old are you and please enter 'quit' when you are finished.")
while True:
    prompt = int(prompt)
    if prompt!='quit':#这里因为int后 肯定不是等于字符串所以会造成不停的循环。然后就会把电脑给崩溃掉。
        if prompt<=3:
            print("price is free")
        elif (prompt > 3) & (prompt < 12):
            print("the price is 10 dollor")
        elif prompt>12:
            print("the price is 15 dollor")
    else:
        break
  ######      看我这串代码，错误的地方很多，。我这里修改了形参，造成之后的循环输出后，还有的就是我这里的input居然写在了最开始，这样就造成了死循环。因为不需要我输入数字了。真的是错误一堆堆。###########################
  prompt1="how old are you?"
prompt1 +="\n please enter 'quit' when you are finished."
while True:
    prompt =input(prompt1)#千万注意这个input（）函数的位置，让他可以循环显示。
    if prompt=='quit':
        break
    prompt=int(prompt)
    if prompt<=3:
        print("price is free")
    elif (prompt > 3) & (prompt < 12):
        print("the price is 10 dollor")
    elif prompt>12:
        print("the price is 15 dollor")
#####################################################################################################   
sandwich_orders = ['veggie', 'grilled cheese', 'turkey', 'roast beef']
finished_sandwiches = []

while sandwich_orders:

    for sandwich_order in sandwich_orders:
        print(f"i made your tuna {sandwich_order} sandwich")
        sandwich_orders.pop()
        finished_sandwiches.append(sandwich_order)
        print(finished_sandwiches)
###############################################################################################这里我做的和书上不同，但是我们共同说明一个问题POP（）出来的数据是从头开始剥离的。这个程序也是错误的。哈哈 因为根本不是从头开始的，而是从尾巴上剔除的。
sandwich_orders = ['veggie', 'grilled cheese', 'turkey', 'roast beef']
finished_sandwiches = []

while sandwich_orders:

    current_sandwich=sandwich_orders.pop()
    print(f"i made your tuna {current_sandwich} sandwich")
    finished_sandwiches.append(current_sandwich)
    print(finished_sandwiches)
   ###############################################################################################应该使用这个程序
   sandwich_orders = [
 'pastrami', 'veggie', 'grilled cheese', 'pastrami',
 'turkey', 'roast beef', 'pastrami']
finished_sandwiches = []
print("I'm sorry, we're all out of pastrami today.")
for sandwich_order in sandwich_orders:
    if sandwich_order=='pastrami':
        sandwich_orders.remove('pastrami')
print(sandwich_orders)

while sandwich_orders:
    current_sandwich=sandwich_orders.pop()
    print(f"i made your tuna {current_sandwich} sandwich")
    finished_sandwiches.append(current_sandwich)
    print(finished_sandwiches)
    ###############################################################
name_prompt = "\nWhat's your name? "
place_prompt = "If you could visit one place in the world, where would it be? "
continue_prompt = "\nWould you like to let someone else respond? (yes/no) "
#调查结果写在字典中,如{name:place}
respose={}
while True:
    name=input(name_prompt)
    place=input(place_prompt)
    respose[name]=place

    repeat=input(continue_prompt)
    if repeat!='yes':
        break
#显示调查结果
print(respose)
for name,place in respose.items():
    print(f"{name} like to visit {place} in the world")
   ############################################################################这个题目讲了字典是怎么生成的，我还以为是用append，其实字典没这个玩意。然后这种写prompt的套路其实是挺好的。
   data=["a","b","c","d","e"]
json = {}
collect=[]
for index,content in enumerate(data):
    json['name']=data[index]
    collect.append(json)
    json = {}#这里把json={}带进去循环
print(collect)
####################在每次循环中，list会增加一个位置用于保存数据。但是json字典在循环外，虽然每次都为该字典重新赋值，但都指的是同一地址，每次赋值给字典都会引起前面所有数据的更新。因此，就会出现数据重复出现。


data=["a","b","c","d","e"]
json = {}
collect=[]
for index,content in enumerate(data):
    collect.append({"name": data[index]})#生成一个临时变量，如果传递到list里面，他会自动给你记录，不会消失、这个涉及形参，实参，地址的知识，需要去补充一下。
print(collect)
#################################################################################这里是列表中生成[{},{},{}]字典数组的方法。上卖弄则是字典中字典的生成方法，所以还是有区别的。字典中字典的方法是无法使用append()函数的。
def display_message():
    print("我学会了啥呢？")
display_message()
###################################
def favorite_book(title):
    """显示一条消息，指出喜欢的一本图书"""
    print(f"{title}is one of my favorite book.")

favorite_book("《faust》")
##########################################形参和实参 说明。
def make_skirt(size,message):
    """描述需要只做什么样的T恤"""
    print(f"这件T恤需要的尺寸是{size}")
    print(f"这件T恤需要印刷的字是{message}")

make_skirt(3,"我爱吃饼干")
make_skirt(message="我要饼干",size="E")
#################################################
def make_skirt(size='large',message='i love Python'):
    """描述需要只做什么样的T恤"""
    print(f"这件T恤需要的尺寸是{size}")
    print(f"这件T恤需要印刷的字是{message}")

make_skirt()#打印默认样子
make_skirt(size="medium")#打印默认字，尺寸选择中
make_skirt(message='i love binggan')#打印默认尺寸，选择字为定制的。
##########################################################如果需要设置默认属性，必须再定义的过程中，把所有的形参都给个默认的定义，如果少一个，会报错
题目是：
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
num1 = [2,7,11,15]
target1 = 9
def bianlifa(nums,target):
    for i in range(0, len(nums) - 1):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                #return [i, j]
                print([i,j])
bianlifa(num1,target1)#如果同一个元素在答案中不能重复出现，就需要涉及到
####################################################################################################################################
def describe_city(city,country='CHINA'):
    """描述城市"""
    print(f"{city.title()} is in {country.title()}")

describe_city('qingdao')
describe_city('tokoyo','japan')
describe_city('bingzhou')
#############################################我在想是不是第一个实参必须给定呢？
def describe_city(city,country):
    return f"{city.title()},{country.title()}"
    """返回一个类似于‘city,country'的字符串"""


city=describe_city('qingdao','china')
print(city)
city=describe_city('tokoyo','japan')
print(city)
city=describe_city('bingzhou','china')
print(city)

####################################################################还是没解决实参第一个是否要给出来，但是需要注意return的用法，这里是返回一个字符串，我写的是打印字符串里面的东西。
def make_album(artist, title):
    """创建一个包含专辑信息的字典"""
    album_dict=dict(art=artist.title(),tit=title.title())#传入关键字
    return album_dict

zhou=make_album("zhoujielun","qinghuaci")
print(zhou)
mao=make_album("maoamin","sinian")
print(mao)
chen=make_album("chenyixun","ten years")
print(chen)############我是用dict()创建的，而下面这种习题答案，作者是用原始的{}创建的，我喜欢我的这种方式，而且我对形参有了更好的书写方式。
def make_album(artist, title):
 """创建一个包含专辑信息的字典。"""
 album_dict = {
 'artist': artist.title(),
 'title': title.title(),
 }
 return album_dict
album = make_album('metallica', 'ride the lightning')
print(album)
album = make_album('beethoven', 'ninth symphony')
print(album)
######################################################################################
字典创建的三种方法：##纠结很久的方法。虽然简单。
1、dic={}#创建一个空的字典外型，这样的type就是字典了。
2、dic2=dict()#
>>>dict()                        # 创建空字典
构建字典的方法如下三种比较常见。
>>> dict(a='a', b='b', t='t')     # 传入关键字
{'a': 'a', 'b': 'b', 't': 't'}
>>> dict(zip(['one', 'two', 'three'], [1, 2, 3]))   # 映射函数方式来构造字典
{'three': 3, 'two': 2, 'one': 1} 
>>> dict([('one', 1), ('two', 2), ('three', 3)])    # 可迭代对象方式来构造字典
{'three': 3, 'two': 2, 'one': 1}
3、dic3={key1:value1,key2:value2}#直接赋值。
########################################################################################
def make_album(artist, title,track=0):
    """创建一个包含专辑信息,数量的字典"""
    album_dict=dict(art=artist.title(),tit=title.title())#传入关键字
    if track!=0:
        album_dict['track']=track

    return album_dict

zhou=make_album("zhoujielun","qinghuaci")
print(zhou)
mao=make_album("maoamin","sinian")
print(mao)
chen=make_album("chenyixun","ten years",track=8)
print(chen)
##########################################################################################
def make_album(artist, title,track=0):
    """创建一个包含专辑信息,数量的字典"""
    album_dict=dict(art=artist.title(),tit=title.title())#传入关键字
    if track!=0:
        album_dict['track']=track

    return album_dict
artist_prompt="\n 请输入歌手名字,If you need to leave ,please enter quit"
title_prompt="请输入专辑名字"
track_prompt="请输入专辑的歌曲数量"
#coutinue_prompt=" If you need to leave ,please enter quit"#这个是退出的，不需要单独赋值了
while True:
    print("If you need to leave ,please enter quit")
    artist=input(artist_prompt)
    if artist=='quit':
        break
    title=input(title_prompt)
    if title=='quit':
        break
    track=input(track_prompt)
    if track=='quit':
        break
    chen=make_album(artist,title,track)
    print(chen)
    #############################################################################################将前段的学习集大成了，这里设置了随时quit的停止机制，使用了while的总领和使用函数的赋值机制。同时再次说明了input（）这种东西的标准写法prompt应该是写在前面的。
    def show_messages(messages):
    """打印每个文本信息"""
    print(f"{messages}")
show_messages("我爱你")
############################################################################################################
def show_message(messages):
    """打印列表中的所有消息"""
    print("showing all message in list")
    for message in messages:
        print(message)
def send_message(messages,sent_message):
    """打印每条消息，然后移到列表sent_message中"""
    print("\n Sending all messages")
    for message in messages:
        sent_message.append(message)
        show_message(sent_message)

messages=['hello there','how are you']
show_message(messages)

sent_message=[]
send_message(messages,sent_message)
#如果是嵌套函数，第一个函数是打印，那么我该如何调用他呢，是我想的第一个问题。所以我用了函数的嵌套，这里注意sent和send 很坑人的。
######################################################################################################################
def make_sandwich(*items):
    """使用指定的食材制作三明治。"""
    print("\n i will make you a great sanwich:")
    for item in items:
        print(f"...add {item} in your sandwitch.")
    print('your sandwitch is ready!')
make_sandwich('roast beef', 'cheddar cheese', 'lettuce', 'honey dijon')
make_sandwich('turkey', 'apple slices', 'honey mustard')
make_sandwich('peanut butter', 'strawberry jam')
#########################主要是两个意义（*item）这个形参的用法是说不知道需要输入多少个形参，他的类型属于tuple(元组）的形式，另外元组的调用就可以使用fo in这样的方式了。形参中还有*kwargs，这种是属于字典的类型。见下面所述。
使用场景：你可以将不定数量的参数传递给一个函数。不定的意思是：预先并不知道, 函数使用者会传递多少个参数给你, 所以在这个场景下使用这两个关键字。其实并不是必须写成 *args 和 **kwargs。 *(星号) 才是必须的. 你也可以写成 *ar 和 k 。而写成 *args 和kwargs 只是一个通俗的命名约定。
*args 表示任何多个无名参数，它本质是一个 tuple。
**kwargs 表示关键字参数，它本质上是一个 dict。
def fun(*args, **kwargs):
    print('args=', args)
    print('kwargs=', kwargs)
fun(1, 2, 3, 4, A='a', B='b', C='c', D='d')
~args = (1, 2, 3, 4)
~kwargs = {'A': 'a', 'B': 'b', 'C': 'c', 'D': 'd'}
##############################################################################################################################
def make_car(manufacturer,model,**options):
    """创建一个表示汽车属性的字典"""
    car_dict={'manufacturer':manufacturer,'model':model}
    for option,value in options.items():
        car_dict[option]=value
        #option1={'value':value,'option':option}
    car_dict.update(options)#这一行也可以不要 不要不要！
    print(car_dict)
car = make_car('subaru', 'outback', color='blue', tow_package=True)
##################################################这里看到**options就是字典的处理方法了，其实并没有把options处理到字典中，只是对他进行了键值对的定义就可以了，相当简约！
class Restaurant():
    """一个表示餐厅的类"""
    def __init__(self,name,cuisine_type):
        """初始化餐厅"""
        self.name=name
        self.cuisine_type=cuisine_type
    def describe_restaurant(self):
        """描述餐厅"""
        print(f"the restaurant name is{self.name},and is a {self.cuisine_type} restaurant")
    def open_restaurant(self):
        """餐厅是否开门"""
        print("the restaurant is opening")

restaurant=Restaurant('binggan','love')
print(restaurant.name)
print(restaurant.cuisine_type)

restaurant.describe_restaurant()
restaurant.open_restaurant()
###########################################################在类中方法后面的self是不能少的，不然会报错。
class Restaurant():
    """一个表示餐厅的类"""
    def __init__(self,name,cuisine_type):
        """初始化餐厅"""
        self.name=name
        self.cuisine_type=cuisine_type
    def describe_restaurant(self):
        """描述餐厅"""
        print(f"the restaurant name is{self.name},and is a {self.cuisine_type} restaurant")
    def open_restaurant(self):
        """餐厅是否开门"""
        print("the restaurant is opening")

bing_gan=Restaurant('binggan','love')
bing_gan.describe_restaurant()

wan_er=Restaurant('waner','young')
wan_er.describe_restaurant()

mi_tao=Restaurant('mitao','friend')
mi_tao.describe_restaurant()
##################################################################无他，不需看
class User():
    """一个表示用户的简单类"""
    def __init__(self,first_name,last_name,username,email,location):
        """初始化用户"""
        self.first_name=first_name
        self.last_name=last_name
        self.username=username
        self.email=email
        self.location=location
    def describe_user(self):
        print(f"{self.username},your email is {self.email},and location is {self.location}")
    def greet_user(self):
        print(f"{self.username} you are welcome")

eric = User('eric', 'matthes', 'e_matthes', 'e_matthes@example.com', 'alaska')
eric.describe_user()
eric.greet_user()
###########################################################类的属性只能在__init__()中表达吗？在类后面的（）中可以写什么东西吗？还有方法后面的（）只能是self吗？可以定义一些吗？
class Restaurant():
    """一个表示餐厅的类"""
    def __init__(self,name,cuisine_type,number_served=0):
        """初始化餐厅"""
        self.name=name
        self.cuisine_type=cuisine_type
    def describe_restaurant(self):
        """描述餐厅"""
        print(f"the restaurant name is{self.name},and is a {self.cuisine_type} restaurant")
    def open_restaurant(self):
        """餐厅是否开门"""
        print("the restaurant is opening")
    def set_number_served(self,number_served):
        """能够设置就餐人数"""
        self.number_served = number_served
        print(f"the restaurant have {self.number_served} people inside")
    def increment_number_served(self,addnumber_served):
        """能够增加用餐人数"""
        self.number_served+=addnumber_served#这里的累加没有用self.addnumber_served，如果用了就报错。为什么呢？
        print(f"餐厅共有{self.number_served}人")

bing_gan=Restaurant('binggan','love')
bing_gan.describe_restaurant()
bing_gan.set_number_served(1257)
bing_gan.increment_number_served(30)
#######################################################################################回答了类中方法后面的（）只能是self吗？可以定义一些吗？这个问题
class User():
    """一个表示用户的简单类"""
    def __init__(self,first_name,last_name,username,email,location):
        """初始化用户"""
        self.first_name=first_name
        self.last_name=last_name
        self.username=username
        self.email=email
        self.location=location
        self.login_attempts=0
    def describe_user(self):
        print(f"{self.username},your email is {self.email},and location is {self.location}")
    def greet_user(self):
        print(f"{self.username} you are welcome")

    def increment_login_attempts(self):
        """将属性 login_attempts 的值加 1。"""
        self.login_attempts+=1
        print(self.login_attempts)
    def reset_login_attempts(self):
        """将属性 login_attempts 重置为0。"""
        self.login_attempts=0


eric = User('eric', 'matthes', 'e_matthes', 'e_matthes@example.com', 'alaska')
eric.describe_user()
eric.greet_user()

print("\nMaking 3 login attempts...")
eric.increment_login_attempts()
eric.increment_login_attempts()
eric.increment_login_attempts()
print(f" Login attempts: {eric.login_attempts}")
print("Resetting login attempts...")
eric.reset_login_attempts()
print(f" Login attempts: {eric.login_attempts}")
##################################################################在类中新加了一个属性self.login_attempts=0，在前面没有定义，在__init__()的（）内没有定义，在下面进行了补充。实例中也没有加上这个形参呢！但是还是可以进行相关之操作。
class Restaurant():
    """一个表示餐厅的类"""
    def __init__(self,name,cuisine_type,number_served=0):
        """初始化餐厅"""
        self.name=name
        self.cuisine_type=cuisine_type
    def describe_restaurant(self):
        """描述餐厅"""
        print(f"the restaurant name is{self.name},and is a {self.cuisine_type} restaurant")
    def open_restaurant(self):
        """餐厅是否开门"""
        print("the restaurant is opening")
    def set_number_served(self,number_served):
        """能够设置就餐人数"""
        self.number_served = number_served
        print(f"the restaurant have {self.number_served} people inside")
    def increment_number_served(self,addnumber_served):
        """能够增加用餐人数"""
        self.number_served+=addnumber_served#这里的累加没有用self.addnumber_served，如果用了就报错。为什么呢？
        print(f"餐厅共有{self.number_served}人")
class IceCreamStand(Restaurant):
    """一个表示冰激凌的小店"""
    def __init__(self,name,cuisine_type='icecreamstand',number_served=0):#试过不用书写这么多属性也可以的，但一般情况都可以写上去。
        """初始化父类的属性，表示接受父类Restaurant父类"""
        super().__init__(name,cuisine_type)#super()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用Restaurant的父类的方法__init__()，让IceCreamStand实例包含父类的所有属性。
        self.flavors=[]
    def show_icecream(self):
        for flavor in self.flavors:
            print(f"we have the follwing icecream -{flavor}")

big_one = IceCreamStand('The Big One')
big_one.flavors = ['vanilla', 'chocolate', 'black cherry']
big_one.describe_restaurant()
big_one.show_icecream()
#######################################################################################################################
class User():
    """一个表示用户的简单类"""
    def __init__(self,first_name,last_name,username,email,location):
        """初始化用户"""
        self.first_name=first_name
        self.last_name=last_name
        self.username=username
        self.email=email
        self.location=location
        self.login_attempts=0
    def describe_user(self):
        """"显示用户信息"""
        print(f"{self.username},your email is {self.email},and location is {self.location}")
    def greet_user(self):
        """"显示用户被欢迎"""
        print(f"{self.username} you are welcome")

    def increment_login_attempts(self):
        """将属性 login_attempts 的值加 1。"""
        self.login_attempts+=1
        print(self.login_attempts)
    def reset_login_attempts(self):
        """将属性 login_attempts 重置为0。"""
        self.login_attempts=0
class Admin(User):
    """描述admin的类"""
    def __init__(self, first_name, last_name, username, email, location):
        """"初始化管理员"""
        super().__init__(first_name, last_name, username, email, location)
        self.privileges=["can add post","can delete post","can ban user"]
    def show_privileges(self):
        """显示用户权限"""
        print("the admin have these privileges")
        for privilege in self.privileges:#注意这里
            print(f" -{privilege}")

eric = Admin('eric', 'matthes', 'e_matthes', 'e_matthes@example.com', 'alaska')
eric.describe_user()#这里调用父类的方法
#eric.privileges = ['can reset passwords','can moderate discussions','can suspend accounts',]
eric.show_privileges()
################注意这里super()__init__()的方法是没有：的。而且在python2.7版本中使用的方法也是不一样。
###############################################################################################################################
class User():
    """一个表示用户的简单类"""
    def __init__(self,first_name,last_name,username,email,location):
        """初始化用户"""
        self.first_name=first_name
        self.last_name=last_name
        self.username=username
        self.email=email
        self.location=location
        self.login_attempts=0
    def describe_user(self):
        """"显示用户信息"""
        print(f"{self.username},your email is {self.email},and location is {self.location}")
    def greet_user(self):
        """"显示用户被欢迎"""
        print(f"{self.username} you are welcome")

    def increment_login_attempts(self):
        """将属性 login_attempts 的值加 1。"""
        self.login_attempts+=1
        print(self.login_attempts)
    def reset_login_attempts(self):
        """将属性 login_attempts 重置为0。"""
        self.login_attempts=0
class Admin(User):
    """描述admin的类"""
    def __init__(self, first_name, last_name, username, email, location):
        """"初始化管理员"""
        super().__init__(first_name, last_name, username, email, location)
        self.privileges=Privileges()


class Privileges():
    """描述privilges的类"""
    def __init__(self,privileges=[]):#这里必须先赋值，因为前面已经被引用了，不赋值会报错。TypeError: __init__() missing 1 required positional argument: 'privileges'
        """初始化admin的类"""
        self.privileges=privileges
    def show_privileges(self):
        """显示用户权限"""
        print("the admin have these privileges")
        for privilege in self.privileges:  # 注意这里self.privileges。
            print(f" -{privilege}")

eric = Admin('eric', 'matthes', 'e_matthes', 'e_matthes@example.com', 'alaska')
eric.describe_user()#这里调用父类的方法
eric.privileges.show_privileges()#两个类之间互相调用，这是现在常用的方式，叫做类的聚合，其实继承用的比较多一些。
eric_privileges = [
 'can reset passwords',
 'can moderate discussions',
 'can suspend accounts',
 ]
eric.privileges.privileges = eric_privileges
eric.privileges.show_privileges()
###########################################################################################这里用了类的聚合和继承方法，做了此题感觉越来越接近实用了。
class Car:
    """A simple attempt to represent a car."""

    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0
        
    def get_descriptive_name(self):
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
    
    def read_odometer(self):
        print(f"This car has {self.odometer_reading} miles on it.")
        
    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")
    
    def increment_odometer(self, miles):
        self.odometer_reading += miles

class Battery:
    """A simple attempt to model a battery for an electric car."""
    
    def __init__(self, battery_size=75):
        """Initialize the battery's attributes."""
        self.battery_size = battery_size

    def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {self.battery_size}-kWh battery.")

    def get_range(self):
        """Print a statement about the range this battery provides."""
        if self.battery_size == 75:
            range = 260
        elif self.battery_size == 100:
            range = 315

        print(f"This car can go about {range} miles on a full charge.")

    def upgrade_battery(self):
        """check the size of battery"""
        if self.battery_size == 75:
            self.battery_size = 100
            print("Upgraded the battery to 100 kWh.")
        else:
            print("The battery is already upgraded.")


class ElectricCar(Car):
    """Represent aspects of a car, specific to electric vehicles."""
    
    def __init__(self, make, model, year):
        """
        Initialize attributes of the parent class.
        Then initialize attributes specific to an electric car.
        """
        super().__init__(make, model, year)
        self.battery = Battery()

    def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {self.battery_size}-kWh battery.")

print("Make an electric car, and check the battery:")
my_tesla = ElectricCar('tesla', 'roadster', 2019)
my_tesla.battery.describe_battery()
print("\nUpgrade the battery, and check it again:")
my_tesla.battery.upgrade_battery()
my_tesla.battery.describe_battery()
print("\nTry upgrading the battery a second time.")
my_tesla.battery.upgrade_battery()
my_tesla.battery.describe_battery()
###############################################################################这里联合调用的方案更加明显，回顾了课本中的案例，类的聚合用法太多了。且更加熟练。这个题目的85是错的，程序根本无法运行。需改正。
from random import randint
class Die:
    """表征一个骰子的类"""
    def __init__(self,sides=6):
        """初始化骰子"""
        self.sides=sides
    def roll_die(self):
        """定义一种掷骰子的方法,返回1到骰子面数之间的随机整数"""
        x = randint(1, self.sides)
        return x
# d6=Die(sides=6)
# print("开始投掷一个面数6的骰子，观察他的面数")
# for i in range(1,11):
#     d6.roll_die()
#
# d20=Die(sides=20)
# print("开始投掷一个面数20的骰子，观察他的面数")
# for i in range(1,11):
#     d20.roll_die()
#
# d10=Die(sides=10)
# print("开始投掷一个面数10的骰子，观察他的面数")
# for i in range(1,11):
#     d10.roll_die()
#以上是野生程序员写的，一般的输出使用list形式给出，如下所示：
results=[]
d6=Die(sides=6)
print("开始投掷一个面数6的骰子，观察他的面数")
for i in range(1,11):
    result=d6.roll_die()
    results.append(result)
print(results)

d20=Die(sides=20)
print("开始投掷一个面数20的骰子，观察他的面数")
for i in range(1,11):
    result=d20.roll_die()
    results.append(result)
print(results)

d10=Die(sides=10)
print("开始投掷一个面数10的骰子，观察他的面数")
for i in range(1,11):
    result=d10.roll_die()
    results.append(result)
print(results)
############################################################################################
from random import choice,sample
possibilities = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 'a', 'b', 'c', 'd', 'e']
#没有随机取出来即有数据，又有数字的随机数组函数，sample只能取出来数字。choice可以随机取出来一个值，这个值可以是数字或者字符
ticket_list=[]
while len(ticket_list)<4:
    L1=choice(possibilities)
    if L1 not in ticket_list:
        ticket_list.append(L1)
print(ticket_list）
######################################################这个程序的意思是在列表中取出来四个个不重复的四个数组，组成一个新的列表。与题目的意思完全不一样。
from random import choice,sample
def get_win_ticket(possibilities):
    """摇出来四个数据组成一个数组作为我们抽出来的结果"""
#没有随机取出来即有数据，又有数字的随机数组函数，sample只能取出来数字。choice可以随机取出来一个值，这个值可以是数字或者字符
    win_ticket=[]
    while len(win_ticket)<4:
        L1=choice(possibilities)
        if L1 not in win_ticket:
            win_ticket.append(L1)
    return win_ticket
def check_ticket(win_ticket,my_ticket):
    """判断是否中奖"""
    for l1 in my_ticket:
        if l1 not in win_ticket:
            return False
    return True
def get_my_ticket(possibilities):
    """抽出来的四个数据"""
    my_ticket=[]
    while len(my_ticket)<4:
        L1=choice(possibilities)
        if L1 not in my_ticket:
            my_ticket.append(L1)
    return my_ticket

possibilities = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 'a', 'b', 'c', 'd', 'e']
win_ticket=get_win_ticket(possibilities)
print(win_ticket)
n=0
won = False
max_tries=1000
while not won:
    my_ticket = get_my_ticket(possibilities)
    won = check_ticket(win_ticket, my_ticket)
    n+=1
    if n>=max_tries:
        won=False
        break
if won:
    print(f"{n},you win,congratuations!")
else:
    print("you are fail")
"""1、这里的while用法需要注意，如果后面接着的是True，那么才能循环，才能走下去。这一点决定是否需要在前面加not
2、这里面没有用cless，只用了def函数就实现了所有的功能，所以是否需要class需要仔细考虑
3、使用return 而不是print，告别野生程序员
4、def（）这个（）中的参数是可以手动赋值的，是很重要的"""
##############################################################################################
filename='learning_python.txt'
print("--- Reading in the entire file:")
with open(filename) as f:
    content=f.read()
print(content)

print("\n--- Looping over the lines:")
with open(filename) as f:
    for line in f:
        print(line.rstrip())

print("\n--- Storing the lines in a list:")
with open(filename) as f:
    lines=f.readlines()#注意这里是readlines()而不是readline(),后者只能读出来一行数据。
    for line in lines:
        print(line.rstrip())
   #########################################################################################
   filename='learning_python.txt'
print("\n--- Storing the lines in a list:")
with open(filename) as f:
    lines=f.readlines()#注意这里是readlines()而不是readline(),后者只能读出来一行数据。
    for line in lines:
        print(line.rstrip().replace('Python','C'))
   #####################################################################################
   filename='learning_python.txt'
name=input("请输入姓名")
with open(filename,'w') as f:
    f.write(name)
#############################################################这种写法会把这个文档中的所有东西清空，然后里面的打开后只看到输入的东西。

filename = 'guest_book.txt'
print("Enter 'quit' when you are finished.")
while True:
    name=input("please enter your name")
    if name=='quit':
        break
    with open(filename,'a') as f:
        f.write(f"{name}\n")
    print(f"{name},you are welcome,you've been added to the guest book.!")
  #############################################################1、这里使用了with open(filename,'a') as f，表示添加功能。2、f"{name}\n"这里在保存的地方增加了回车键，是类似与打印的方式。
filename = 'programming_poll.txt'
responses = []
while True:
    response = input("\nWhy do you like programming? ")
    responses.append(response)
    continue_poll = input("Would you like to let someone else respond? (y/n) ")
    if continue_poll != 'y':
        break
with open(filename, 'a') as f:
    for response in responses:
        f.write(f"{response}\n")
####################################这种套路真是思路非常之清晰。
print("Enter 'q' at any time to quit.\n")
while True:
    try:
        x = input("please enter a number")
        if x == "q":
            break
        x = int(x)
        y = input("please enter another number")
        if y == "q":
            break
        y = int(y)

    except ValueError:
        print("i really nead a number")
        #continue
    else:
        z = x + y
        print(f"the two number{x} &{y}have result is {z}")
#############################################################使用了while来实现这个循环，而不是用continue来实现的。
filenames = ['cats.txt','dogs.txt']
try:
    for filename in filenames:
        print(f"we will read this file {filename}")
        with open(filename) as f:
            content=f.read()
            print(content)
except ValueError:
    print("i cannot find this file.")
#将多个文件做到列表中进行读取。是非常具有现实意义的。这里不需要while，因为不需要循环读取。我这种写法是非常业余的写法，下面是官方所写的
filenames = ['cats.txt','dogs.txt']
for filename in filenames:
    try:
        with open(filename) as f:
            content=f.read()
    except FileNotFoundError:
        print("i cannot find this file.")
    else:
        print(f"\n Reading file:{filename}")
        print(content)
 ####################################################################说明不用else:也可以写完这个程序的。
def count_common_words(filename, word):
    """计算指定的单词在图书中出现了多少次。"""
 # 请注意，这里计算得到的结果并不准确，比实际出现的次数要多。"""

    with open(filename,encoding='UTF-8') as f:
        lines=f.readlines()
        n=0
        for line in lines:
            n+=line.lower().count(word)
        print(n)

filename='alice.txt'
count_common_words(filename,'the')
#我还以为必须一行行的读取才能取到重复的次数后来发现不需要这么麻烦，用f.read()读取就可以了。其实也不需要try， excepet ，else吧，错了 或者没有这个文件让他自己报错就是了，目前我这么认为的。以下是官方写的程序。
def count_common_words(filename, word):
    try:

        with open(filename, encoding='utf-8') as f:
            contents = f.read()
    except FileNotFoundError:
        pass
    else:
        word_count = contents.lower().count(word)
        msg = f"'{word}' appears in {filename} about {word_count} times."
        print(msg)
filename = 'alice.txt'
count_common_words(filename, 'the')
#######################################################################
