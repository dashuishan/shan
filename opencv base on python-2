import cv2 as cv
import numpy as np
import sys


if __name__ == '__main__':
    # 1. 以矩阵为例
    src = np.array([[1, 2, 3, 4, 5],
                    [6, 7, 8, 9, 10],
                    [11, 12, 13, 14, 15],
                    [16, 17, 18, 19, 20],
                    [21, 22, 23, 24, 25]], dtype='float32')
    kernel1 = np.array([[1, 1, 1],
                        [1, 1, 1],
                        [1, 1, 1]], dtype='float32') / 9
    result = cv.filter2D(src, -1, kernel=kernel1)
    print('卷积前矩阵：\n{}'.format(src))
    print('卷积后矩阵：\n{}'.format(result))

    # 2. 以图像为例
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/lena.jpg')
    if img is None:
        print('Failed to read lena.jpg.')
        sys.exit()
    kernel2 = np.ones((7, 7), np.float32) / 49
    result2 = cv.filter2D(img, -1, kernel=kernel2)

    # 展示结果
    cv.imshow('Origin Image', img)
    cv.imshow('Filter Result', result2)
    cv.waitKey(0)
    cv.destroyAllWindows()
    ###################################################1、这里的核为了防止卷积后过大，会把核里面的每个数字都除以和，让每个值相加等于1；2、cv.filter2D()参数中的ddepth参数是
    =-1表示输入输出为相同类型的图片。3、最后参数borderType表示像素边界外推法选择标志。
###########################################################################################
import cv2 as cv
import numpy as np


if __name__ == '__main__':
    src = np.array([[1, 2, 3, 4, 5],
                    [6, 7, 8, 9, 10],
                    [11, 12, 13, 14, 15],
                    [16, 17, 18, 19, 20],
                    [21, 22, 23, 24, 25]], dtype='float32')
    dst = cv.flip(src, -1)#这里的cv.flip(,-1)指的是先X轴旋转，再Y轴旋转
    print('原卷积模板为：\n{}'.format(src))
    print('旋转180°后的卷积模板为：\n{}'.format(dst))
####################################################################################
import cv2 as cv
import numpy as np
import sys


def add_noisy(image, n=10000):
    result = image.copy()
    w, h = image.shape[:2]
    for i in range(n):
        # 分别在宽和高的范围内生成一个随机值，模拟代表x, y坐标
        x = np.random.randint(1, w)
        y = np.random.randint(1, h)
        if np.random.randint(0, 2) == 0:
            # 生成白色噪声（盐噪声）
            result[x, y] = 0
        else:
            # 生成黑色噪声（椒噪声）
            result[x, y] = 255
    return result


if __name__ == '__main__':
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/dolphins.jpg')
    if img is None:
        print('Failed to read dolphins.jpg.')
        sys.exit()
    # 灰度图像添加椒盐噪声
    gray_image = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    gray_image_noisy = add_noisy(gray_image, 10000)
    # 彩色图像添加椒盐噪声
    color_image_noisy = add_noisy(img, 10000)

    # 展示结果
    cv.imshow("Gray Image", gray_image)
    cv.imshow("Gray Image Noisy", gray_image_noisy)
    cv.imshow("Color Image", img)
    cv.imshow("Color Image Noisy", color_image_noisy)
    cv.waitKey(0)
    cv.destroyAllWindows()
##################################################################椒盐噪声是黑的椒和白色的盐两种的组合。
import cv2 as cv
import numpy as np
import sys


def add_noise(image, mean=0, val=0.01):
    size = image.shape
    image = image / 255
    gauss = np.random.normal(mean, val ** 0.5, size)#np.random.normal中的参数size为输出的维度。
    noise = image + gauss
    return gauss, noise


if __name__ == '__main__':
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/dolphins.jpg')
    if img is None:
        print('Failed to read dolphins.jpg.')
        sys.exit()
    # 灰度图像添加高斯噪声
    gray_image = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    gray_gauss, gray_noisy_image = add_noise(gray_image)
    print(gray_gauss)
    # 彩色图像添加高斯噪声
    color_gauss, color_noisy_image = add_noise(img)

    # 展示结果
    cv.imshow("Gray Image", gray_image)
    cv.imshow("Gray Gauss Image", gray_gauss)
    cv.imshow("Gray Noisy Image", gray_noisy_image)
    cv.imshow("Color Image", img)
    cv.imshow("Color Gauss Image", color_gauss)
    cv.imshow("Color Noisy Image", color_noisy_image)
    cv.waitKey(0)
    cv.destroyAllWindows()
#########################################################################1、np.random.normal()高斯分布可以输出多个维度的数据。2、定义函数的时候设置了初始的（mean和val)所以在后面的使用函数的过程中
####就没有给出新的mean和val了。3、高斯噪声此处的平均值设置到0，但是图像像素的值在(0，255)，因此在程序中将图像归一化除以255，让高斯造成更加明显的体现出来。
####################################################################
import cv2 as cv
import sys


def my_blur(image):
    return cv.blur(image, (3, 3)), cv.blur(image, (9, 9))


if __name__ == '__main__':
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/Gray_dolphins.jpg')
    if img is None:
        print('Failed to read Gray_dolphins.jpg.')
        sys.exit()

    img_sp = cv.imread('./images/GraySaltPepperImage.jpg')
    if img_sp is None:
        print('Failed to read GraySaltPepperImage.jpg.')
        sys.exit()

    img_gauss = cv.imread('./images/GrayGaussImage.jpg')
    if img_gauss is None:
        print('Failed to read GrayGaussImage.jpg.')
        sys.exit()

    img1, img2 = my_blur(img)
    img_sp1, img_sp2 = my_blur(img_sp)
    img_gauss1, img_gauss2 = my_blur(img_gauss)

    # 展示结果
    cv.imshow('Origin Image', img)
    cv.imshow('3 * 3 Blur Image', img1)
    cv.imshow('5 * 5 Blur Image', img2)

    cv.imshow('Origin sp-noisy Image', img_sp)
    cv.imshow('3 * 3 sp-noisy Blur Image', img_sp1)
    cv.imshow('5 * 5 sp-noisy Blur Image', img_sp2)

    cv.imshow('Origin gauss-noisy Image', img_gauss)
    cv.imshow('3 * 3 gauss-noisy Blur Image', img_gauss1)
    cv.imshow('5 * 5 gauss-noisy Blur Image', img_gauss2)

    cv.waitKey(0)
    cv.destroyAllWindows()
##########################################################################cv.blur()blur英文的意思是模糊。在实际中就是没有180度旋转的卷积运算。k值做了自动的归一化处理，真个函数处理后，从表面看来没有使图片更加清晰。
import numpy as np
import sys


if __name__ == '__main__':
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/equalLena.png', cv.IMREAD_ANYDEPTH)
    if img is None:
        print('Failed to read equalLena.png.')
        sys.exit()

    # 验证方框滤波算法的数组矩阵
    points = np.array([[1, 2, 3, 4, 5],
                       [6, 7, 8, 9, 10],
                       [11, 12, 13, 14, 15],
                       [16, 17, 18, 19, 20],
                       [21, 22, 23, 24, 25]], dtype='float32')

    # 将图像转为float32类型的数据
    img_32 = img.astype('float32')
    img_32 /= 255.0

    # 方框滤波cv.boxFilter()和cv.sqrBoxFilter()
    # 进行归一化
    img_box_norm = cv.boxFilter(img, -1, (3, 3), anchor=(-1, -1), normalize=True)
    # 不进行归一化
    img_box = cv.boxFilter(img, -1, (3, 3), anchor=(-1, -1), normalize=False)

    # 进行归一化
    points_sqr_norm = cv.sqrBoxFilter(points, -1, (3, 3), anchor=(-1, -1),
                                      normalize=True, borderType=cv.BORDER_CONSTANT)
    img_sqr_norm = cv.sqrBoxFilter(img, -1, (3, 3), anchor=(-1, -1),
                                    normalize=True, borderType=cv.BORDER_CONSTANT)
    # 不进行归一化
    points_sqr = cv.sqrBoxFilter(points, -1, (3, 3), anchor=(-1, -1),
                                 normalize=False, borderType=cv.BORDER_CONSTANT)
    print(points_sqr)
    print(points_sqr_norm)
    # 展示图像处理结果
    cv.imshow('Result(cv.boxFilter() NORM)', img_box_norm)
    cv.imshow('Result(cv.boxFilter()', img_box)
    cv.imshow('Result(cv.sqrBoxFilter() NORM', img_sqr_norm / np.max(img_sqr_norm))
    cv.waitKey(0)
    cv.destroyAllWindows()
####################################################分别使用CV.sqrBoxFilter()和CV.boxFilter()两个函数进行图像滤波，如果不归一化从结果看来图像很容易呈现曝光过度的现象，失去了很多细节。
####不明白这里的 img_32 /= 255.0,如果我不用的话，显示的图像也是差不多的效果。
######################################################################################
import cv2 as cv
import sys


if __name__ == '__main__':
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/Gray_dolphins.jpg', cv.IMREAD_ANYDEPTH)
    img_gauss = cv.imread('./images/GrayGaussImage.jpg', cv.IMREAD_ANYDEPTH)
    img_salt = cv.imread('./images/GraySaltPepperImage.jpg', cv.IMREAD_ANYDEPTH)
    if img is None or img_gauss is None or img_salt is None:
        print('Failed to read Gray_dolphins.jpg or GrayGaussImage.jpg or GraySaltPepperImage.jpg.')
        sys.exit()

    # 分别对上述图像进行高斯滤波，后面的数字代表滤波器尺寸
    result_5 = cv.GaussianBlur(img, (5, 5), 10, 20)
    result_9 = cv.GaussianBlur(img, (9, 9), 10, 20)
    result_5_gauss = cv.GaussianBlur(img_gauss, (5, 5), 10, 20)
    result_9_gauss = cv.GaussianBlur(img_gauss, (9, 9), 10, 20)
    result_5_salt = cv.GaussianBlur(img_salt, (5, 5), 10, 20)
    result_9_salt = cv.GaussianBlur(img_salt, (9, 9), 10, 20)

    # 展示结果
    cv.imshow('Origin img', img)
    cv.imshow('Result img 5*5', result_5)
    cv.imshow('Result img 9*9', result_9)
    cv.imshow('Origin img_gauss', img_gauss)
    cv.imshow('Result img_gauss 5*5', result_5_gauss)
    cv.imshow('Result img_gauss 9*9', result_9_gauss)
    cv.imshow('Origin img_salt', img_salt)
    cv.imshow('Result img_salt 5*5', result_5_salt)
    cv.imshow('Result img_salt 9*9', result_9_salt)
    cv.waitKey(0)
    cv.destroyAllWindows()
##################################################在均值滤波中可以看到其实是图像经过卷积得到的结果，这样的图像是变得更加模糊了，这就是神经卷积网络的基础。还有需要思考的问题是高频和低频
##################只是相对物理滤波器而言，那么数字滤波器哪里来的高频和低频呢。另外高斯滤波依然会把图像变得更加模糊。
import cv2 as cv
import numpy as np
import sys

if __name__ == '__main__':
    # 验证滤波算法的数据矩阵
    data = np.array([[1, 2, 3, 4, 5],
                    [6, 7, 8, 9, 10],
                    [11, 12, 13, 14, 15],
                    [16, 17, 18, 19, 20],
                    [21, 22, 23, 24, 25]], dtype='float32')

    # 构建X方向、Y方向和联合滤波器
    a = np.array([[-1], [3], [-1]])
    b = a.reshape((1, 3))
    ab = a * b
    print(f"ab是{ab}")
    # 验证高斯滤波的可分离性
    gaussX = cv.getGaussianKernel(3, 1)#cv.getGaussianKernel()用来生成指定大小的高斯滤波器，将生成结果放在维度为ksize*1得ndarray数组对象中并返回。
    #3 是ksize参数，高斯滤波器得半径。1是高斯滤波的标准差。
    gauss_data = cv.GaussianBlur(data, (3, 3), 1, None, 1, cv.BORDER_CONSTANT)
    gauss_data_XY = cv.sepFilter2D(data, -1, gaussX, gaussX, None, (-1, -1), 0, cv.BORDER_CONSTANT)
    print('采用cv.GaussianBlur方式：\n{}'.format(gauss_data))
    print('采用cv.sepFilter2D方式：\n{}'.format(gauss_data_XY))

    # 线性滤波的可分离性
    data_Y = cv.filter2D(data, -1, a, None, (-1, -1), 0, cv.BORDER_CONSTANT)
    data_YX = cv.filter2D(data_Y, -1, b, None, (-1, -1), 0, cv.BORDER_CONSTANT)
    data_XY = cv.filter2D(data, -1, ab, None, (-1, -1), 0, cv.BORDER_CONSTANT)
    data_XY_sep = cv.sepFilter2D(data, -1, b, b, None, (-1, -1), 0, cv.BORDER_CONSTANT)
    print('data_Y=\n{}'.format(data_Y))
    print('data_YX=\n{}'.format(data_YX))
    print('data_XY=\n{}'.format(data_XY))
    print('data_XY_sep=\n{}'.format(data_XY_sep))

    # 对图像进行分离操作
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/lena.jpg')
    if img is None:
        print('Failed to read lena.jpg.')
        sys.exit()

    img_Y = cv.filter2D(img, -1, a, None, (-1, -1), 0, cv.BORDER_CONSTANT)
    img_YX = cv.filter2D(img_Y, -1, b, None, (-1, -1), 0, cv.BORDER_CONSTANT)
    img_XY = cv.filter2D(img, -1, ab, None, (-1, -1), 0, cv.BORDER_CONSTANT)

    # 展示结果
    cv.imshow('Origin', img)
    cv.imshow('img Y', img_Y)
    cv.imshow('img YX', img_YX)
    cv.imshow('img XY', img_XY)
    cv.waitKey(0)
    cv.destroyAllWindows()
################################################使用filter2D()的X和Y轴的高斯滤波后，图像得到了更加清晰的展示。为什么呢？虽然这里也是使用了高斯滤波，但是呈现出来不同的特征。
#########################################cv.sepFilter2D(cv.getGaussianKernel)和一个cv.GaussianBlur()是等价的效果。
#######################################data_YX，data_XY，data_XY_sep都是相同的，线性滤波具备可分离的特点。
import cv2 as cv
import sys
if __name__ == '__main__':
    # 读取图像并判断是否读取成功
    img = cv.imread('./images/ColorSaltPepperImage.jpg', cv.IMREAD_ANYCOLOR)
    gray = cv.imread('./images/GraySaltPepperImage.jpg', cv.IMREAD_ANYCOLOR)
    if img is None or gray is None:
        print('Failed to read ColorSaltPepperImage.jpg or ColorSaltPepperImage.jpg.')
        sys.exit()

    # 分别对含有椒盐噪声的彩色和灰度图像进行中值滤波，后面的数字代表滤波器尺寸
    img_3 = cv.medianBlur(img, 3)
    gray_3 = cv.medianBlur(gray, 3)
    # 加载滤波器尺寸，图像会变模糊
    img_9 = cv.medianBlur(img, 9)
    gray_9 = cv.medianBlur(gray, 9)

    # 展示结果
    cv.imshow('Origin img', img)
    cv.imshow('img 3*3', img_3)
    cv.imshow('img 9*9', img_9)
    cv.imshow('Origin gray', gray)
    cv.imshow('gray 3*3', gray_3)
    cv.imshow('gray 9*9', gray_9)
    cv.waitKey(0)
    cv.destroyAllWindows()
##################################################非线性的中值滤波对噪声具有更好的抑制作用，同时在一定的条件下，中值滤波对图像的边缘信息保护得更好，可以避免图像细节的模糊。但是如果KSIZE过大也会造成图像模糊问题。
import cv2 as cv
import sys


if __name__ == '__main__':
    # 读取图像face1.png和face2.png
    image1 = cv.imread('./images/face1.png', cv.IMREAD_ANYCOLOR)
    image2 = cv.imread('./images/face2.png', cv.IMREAD_ANYCOLOR)
    if image1 is None or image2 is None:
        print('Failed to read face1.png or face2.png.')
        sys.exit()

    # 验证不同滤波器直径的滤波效果
    res1 = cv.bilateralFilter(image1, 9, 50, 25 / 2)
    res2 = cv.bilateralFilter(image1, 25, 50, 25 / 2)

    # 验证不同标准差值的滤波效果
    res3 = cv.bilateralFilter(image2, 9, 9, 9)
    res4 = cv.bilateralFilter(image2, 9, 200, 200)

    # 展示结果
    cv.imshow('Origin_image1', image1)
    cv.imshow('Origin_image2', image2)
    cv.imshow('Result1', res1)
    cv.imshow('Result2', res2)
    cv.imshow('Result3', res3)
    cv.imshow('Result4', res4)

    cv.waitKey(0)
    cv.destroyAllWindows()
################################################################双边滤波是两个滤波器功能的叠加 分别是空间滤波器和值域滤波器图像像素灰度值相似性的滤波器。
##############################cv.bilateralFilter(image2, 9, 200, 200)这里的9是滤波器的滤波器的大小，200，200分别是颜色空间滤波器的标准差，空间坐标中滤波器的标准差。
#########################################双边滤波具有美颜的效果。
import cv2 as cv
import numpy as np
import sys

if __name__ == '__main__':
    # 读取图像equalLena.png
    image = cv.imread('./images/equalLena.png', cv.IMREAD_ANYCOLOR)
    if image is None:
        print('Failed to read equalLena.png.')
        sys.exit()

    # 创建边缘检测滤波器
    kernel1 = np.array([1, -1])
    kernel2 = np.array([1, 0, -1])
    kernel3 = kernel2.reshape((3, 1))
    kernel4 = np.array([1, 0, 0, -1]).reshape((2, 2))
    kernel5 = np.array([0, -1, 1, 0]).reshape((2, 2))

    # 检测图像边缘
    # 以[1, -1]检测水平方向边缘
    res1 = cv.filter2D(image, cv.CV_16S, kernel1)
    res1 = cv.convertScaleAbs(res1)
    # 以[1, 0, -1]检测水平方向边缘
    res2 = cv.filter2D(image, cv.CV_16S, kernel2)
    res2 = cv.convertScaleAbs(res2)
    # 以[1, 0, -1]检测垂直方向边缘
    res3 = cv.filter2D(image, cv.CV_16S, kernel3)
    res3 = cv.convertScaleAbs(res3)
    # 整幅图像边缘
    res = res2 + res3
    # 检测由左上到右下方向边缘
    res4 = cv.filter2D(image, cv.CV_16S, kernel4)
    res4 = cv.convertScaleAbs(res4)
    # 检测由右上到左下方向边缘
    res5 = cv.filter2D(image, cv.CV_16S, kernel5)
    res5 = cv.convertScaleAbs(res5)

    # 展示结果
    cv.imshow('Result1', res1)
    cv.imshow('Result2', res2)
    cv.imshow('Result3', res3)
    cv.imshow('Result', res)
    cv.imshow('Result4', res4)
    cv.imshow('Result5', res5)
    cv.waitKey(0)
    cv.destroyAllWindows()
#######################################################cv.convertScaleAbs()处理之后对矩阵中所有数据取绝对值。这样就把边缘处的轮廓求出来了。
